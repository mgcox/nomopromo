{
  "author": {
    "name": "Brian Carr",
    "email": "bcarr14@gmail.com"
  },
  "name": "stringrouter",
  "description": "A restful URL parsing and routing component.",
  "version": "0.3.3",
  "repository": {
    "type": "git",
    "url": "http://github.com/mrmarbles/stringrouter.git"
  },
  "main": "index",
  "engines": {
    "node": "*"
  },
  "devDependencies": {
    "nodeunit": ">= 0.7.4"
  },
  "dependencies": {
    "stringtokenizer": ">= 0.0.4"
  },
  "scripts": {
    "test": "nodeunit test/"
  },
  "keywords": [
    "rest",
    "restful",
    "url",
    "parser",
    "parsing",
    "web service"
  ],
  "license": "MIT",
  "readme": "[![Build Status](https://travis-ci.org/mrmarbles/stringrouter.png)](https://travis-ci.org/mrmarbles/stringrouter)\r\n\r\nstringrouter\r\n=======\r\nStringRouter is a high-level routing API that parses, parameterizes and binds string patterns to the invocation of\r\ncallback functions. Can be easily used to deploy restful web service endpoints without the overhead of a full-stack framework or simply\r\nparse path-info from URL strings.  See the examples for more details.\r\n\r\nInstallation\r\n---------------\r\n\tnpm install stringrouter\r\n\r\nTesting\r\n---------------\r\n    npm test\r\n\t\r\n### Basic API\r\n---------------\r\nThe below code is intended only to demonstrate basic `StringRouter` usage.  \r\nHere, the string `some string` is registered as a simple string\r\npattern that the router will recognize so that future calls to `dispatch()` (more details on that method below)\r\nwill attempt to match the provided string with previously registered patterns, and invoke\r\na callback method when a match is detected.\r\n\r\n```javascript\r\nvar stringrouter = require('stringrouter');\r\n\r\nvar router = stringrouter.getInstance();\r\n\r\nrouter.bindPattern('/people');\r\n\r\nrouter.dispatch('/people', function(err, packet) {\r\n\t/*\r\n\t * Both the err and packet objects passed to the \r\n\t * callback in this case will be undefined because\r\n\t * no variables were defined in the string pattern\r\n\t * and the provided '/people' string will 'find' the\r\n\t * previously registered string '/people'.\r\n\t */\t\t\r\n});\r\n```\r\n\t\r\nAny number of patterns can be declared for a given instance of `StringRouter`.\r\n\r\n### What does the 'packet' contain?\r\n\r\nThe `packet` argument passed to the dispatch callback is a representation of several pieces\r\nof information collected during the execution lifecycle.  It is an object containing three keys;\r\n\r\n* **config**: If you configured this specific instance of your `StringRouter`, then that configuration\r\nwill be represented here.\r\n\r\n* **params**: This is a key/value hash representing each configured string variable for the matched pattern.  See the\r\n'Using String Variables' section.\r\n\r\n* **data**: An optional and abitrary data type passed through from the call to `dispatch();`.\r\n\r\n### The dispatch() method in detail\r\n\r\nThe method signature for dispatch is as follows `dispatch(string, callback, data);`\r\n\r\nOnce one or more patterns have been configured for your `StringRouter` instance, an invocation of\r\n`dispatch()` is required in order to determine matches to the patterns.  That method accepts up to three arguments;\r\n\r\n* **string**: String against which all previously registered patterns will be evaluated to determine a match.\r\n\r\n* **callback**: A callback method that will be invoked regardless as to whether or not a match for the `string` argument was found.  The method\r\nsignature for this function is `callback(err, packet)`.  The `err` argument will only be defined if no registered pattern was matched\r\nfor the first string argument of `dispatch()`.  The `packet` argument will always be defined, and contain contextual and runtime information\r\nas described in the 'What does the packet contain' section above.\r\n\r\n* **data**: Any arbitrary data that you would like to pass through the function execution lifecycle.  \r\nThis data will be represented inside of the `packet` with a key named `data` and can be accessed and/or manipulated\r\nat any point in the execution lifecycle - inside of a matched pattern-bound callback or inside of the callback function\r\nprovided to the `dispatch()` method itself. \r\n\t\r\n### Using String Variables\r\n\r\nBelow is an example of a pattern with a declared variable.  String variables are declared\r\ninside of the pattern as a name, demarcated with surrounding curly-braces `{myvariable}`.  As a rule,\r\nvariables will match any alphanumeric character set including dashes and underscores.\r\n\r\n```javascript\r\nvar stringrouter = require('stringrouter');\r\n\r\nvar router = stringrouter.getInstance();\r\n\r\nrouter.bindPattern('/do/{something}');\r\n```\r\n\r\nThe above pattern is indicating that anything succeeding `/do/..` will be considered a variable, and match\r\nthe pattern.  The name you give your variable is important, as it will be provided to the `dispatch()` function as an object literal\r\nwith properties whose values represent the value of the URL variables;\r\n\r\n```javascript\r\nvar stringrouter = require('stringrouter');\r\n\r\nvar router = stringrouter.getInstance();\r\n\r\nrouter.bindPattern('/hello/{hello}');\r\n\r\nrouter.dispatch('/hello/world', function(err, packet) {\r\n\t/*\r\n\t * This string will match the /hello/world pattern, as as such,\r\n\t * the packet.params argument provided to this callback will contain\r\n\t * an object with a property named 'hello' with the value 'world'.\r\n\t */\r\n});\r\n\r\nrouter.dispatch('/hello/brian', function(err, packet) {\r\n\t/*\r\n\t * This string will also match the previously registered\r\n\t * pattern.  In this case, packet.params.hello will have the value\r\n\t * 'brian'.\r\n\t */\r\n});\r\n```\r\n\t\r\nAny number of variables can be delcared in a single string\r\n\r\n```javascript\r\nrouter.bindPattern('/one/{two}/three/{four}');\r\n```\r\n\t\r\n### Using Custom Matching Rules\r\n\r\nThere will be cases when you'll want to hone how matches are considered for any provided\r\npattern.  This can be done easily by providing a regular expression inside of your string variable;\r\n\r\n```javascript\r\nrouter.bindPattern('/user/{id:[0-9]{5}}');\r\n```\r\n\t\r\nAnything succeeding the colon `:` in a named variable will be used as a regular expression in order to determine\r\nmatches for the given pattern.  Remember to keep it contained within the curly braces.  In the above example, the pattern\r\nis indicating only 5-digit numeric values will be matched as the string variable.\r\n\r\nThis is useful when you want to avoid pattern collisions.  Consider the following scenario;\r\n\r\n```javascript\r\nrouter.bindPattern('/user/{id}');\r\nrouter.bindPattern('/user/{username}');\r\n```\r\n\t\r\nThe above patterns are functionally equivalent.  Which means that if you needed matches to the \r\nthe second pattern to execute different logic than the first (see the section on pattern-bound callbacks),\r\nyou would need to specify a different pattern entirely.  Of course that's not necessary with `StringRouter`, you can simply\r\nmake the matching rules more specific according to your needs;\r\n\r\n```javascript\r\nrouter.bindPattern('/user/{id:some regex here}');\r\nrouter.bindPattern('/user/{username:another regex here}');\r\n```\r\n\r\n### Pattern-Bound Callbacks\r\n\r\nChances are you'll want to be able to execute code specific to a given route.  This can be done easily\r\nwith the introduction of a pattern-bound callback is invoked when a string match is detected when `dispatch()` is called;\r\n\r\n```javascript\r\nrouter.bindPattern('/user/{id}', function(packet, callback) {\r\n    // this code will be executed\r\n});\r\n```\r\n\t\r\nYou'll notice there's no `err` object available to provided callback.  That's because the match to the pattern\r\nis guaranteed.  If a string that doesn't match the pattern is provided to `dispatch()`, then of course the pattern-bound\r\ncallback is never invoked.\r\n\r\nThe `packet` argument is an object containing the key/value pairs for the parsed URL variables of the provided\r\nstring to `dispatch` as well as `config` and `data` if it was provided to `dispatch()`.\r\n\r\nThe `callback` argument is the callback provded as the second argument to `dispatch()`.  It is the responsibility of\r\nthe pattern-bound callback to invoke the `dispatch()` callback with the appropriate arguments \r\nif control is to be given to that function.\r\n\r\n```javascript\r\nrouter.bindPattern('/user/{id}', function(packet, callback) {\r\n\t/*\r\n\t * Execute logic specific to this pattern here.  You have access\r\n\t * to the packet object.  Also, don't forget to invoke the provided\r\n\t * dispatch callback to provide control to that function.\r\n\t *\r\n\t * In the below example, we need to ensure that scope, and the errors\r\n\t * object are what that callback expects.\r\n\t */\r\n\tcallback.call(undefined, undefined, packet);\r\n});\r\n```\r\n\t\r\n### Simple Match Testing\r\n\r\nIf you want to see if a given string pattern matches any pattern registered with an instance of `StringRouter` without having to explicitly call `dispatch()`\r\nthen you can simply ask the `StringRouter` if it has a match for a provided string;\r\n\r\n```javascript\r\nrouter.hasMatch('hello world');\r\n```\r\n\t\r\nNo callbacks, no mess - it will simply return a boolean indicating if the given string matches any registered patterns.  Of course using `dispatch()` is much more \r\nrobust and will provide you with much more information about the match and control over what happens next, this is a good way of knowing up front what would happen\r\nshould a call to `dispatch()` be made.\r\n\r\n### Function Execution Lifecycle\r\n\r\nThis is really just a fancy name for what to expect when you invoke the `dispatch()` method.  If no pattern-bound functions have been declared for a `StringRouter` instance,\r\nthen the lifecycle is very straight-forward - the provided callback to `dispatch()` is invoked, populating `err` depending upon whether or not a registered pattern matched\r\nthe string.  As stated previously `packet` is always populated.\r\n\r\nThe lifecycle is only slightly more complex when a pattern-bound function has been declared.  When a match is made on a pattern that has a bound function like so;\r\n\r\n```javascript\r\nrouter.bindPattern(\"/hello/world\", function(packet, callback) {\r\n\r\n});\r\n```\r\n \r\n..then control is handed to this function **before** the callback provided to `dispatch()` can be invoked.  In fact, in these cases, it is the sole responsibility of\r\nthis function to execute the callback originally provided to `dispatch()` - because it's the `callback` argument in this method.  This means that if you never invoke\r\nthat method, then you may not get the expected results from your original call to `dispatch()`.\r\n\r\n### Namespacing\r\n\r\nThe `StringRouter` API provides a convenient way to isolate sets of patterns in the form of namespaces.  Namespaces are represented with arbitrary string values like so;\r\n\r\n```javascript\r\nrouter.namespace('somekey').bindPattern(...);\r\n```\r\n\r\nOr the more convenient, truncated method;\r\n\r\n```javascript\r\nrouter.ns('somekey').bindPattern(...);\r\n```\r\n\r\nOnce a pattern is bound to a specific namespace, you'll need to specify that namespace when invoking the `dispatch()` method in order to execute the pattern match against that context;\r\n\r\n```\r\nrouter.ns('somekey').dispatch(...);\r\n```\r\n\r\nAny number of namespaces can be created for any given `StringRouter` instance.  You can query the router to determine what namespaces it is maintaining with `namespaces()`;\r\n\r\n```javascript\r\nrouter.namespaces();\r\n```\r\n\r\nOf course, invoking `dispatch()` under a specific namespace (or no namespace at all) will not evaluate any patterns registered under a different namespace - which of course, is the whole point.\r\n\t\r\n### Basic Configuration\r\n\r\nInstances of `StringRouter` support only one configurable property; `noMatch`.  When `dispatch()` is invoked, and no patterns are matched, then the callback\r\nfunction is invoked with an initialized `err` object.  That objects looks like this; `{error: 'No Match'}`.  You can override this value with the `noMatch` configuration;\r\n\r\n```javascript\r\nvar router = stringrouter.getInstance({\r\n\tnoMatch: 'Any value - simple or complex can go here.'\r\n});\r\n```\r\n\t\r\nNow when the `err` object is evaluated (when no pattern matches exist) inside of the `dispatch()` callback, you'll see that it's value is the simple string we've provided\r\nabove.\r\n\r\nConfiguring your `StringRouter` instance can be useful in other ways too.  As a part of the `packet` variable that is made available throughout the function execution lifecycle,\r\nyou have access to `config` - which as you've probably already guessed, is the variable you passed into the initial `getInstance()` method.  So, you can add any number of arbitrary\r\nkeys and values to the configuration and have access to them inside of `packet.config` throughout the function execution lifecycle.\r\n\t\r\n### Not Found\r\n\r\nIn the cases when the first argument to `dispatch()` is a string that does not match\r\nany previously registered patterns, then the callback provided to that method will be\r\ninvoked with an `err` object passed as the first argument.  This object will contain a single\r\nproperty named `error` containing the string 'No Match'.\r\n\r\nLicense\r\n-------\r\n[MIT License](http://mrmarbles.mit-license.org/ \"Mit License\")",
  "readmeFilename": "README.md",
  "_id": "stringrouter@0.3.3",
  "dist": {
    "shasum": "67de39db9895251cc1e92ed32139316e75de1bee",
    "tarball": "http://registry.npmjs.org/stringrouter/-/stringrouter-0.3.3.tgz"
  },
  "_from": "stringrouter@0.3.3",
  "_npmVersion": "1.2.14",
  "_npmUser": {
    "name": "mrmarbles",
    "email": "bcarr14@gmail.com"
  },
  "maintainers": [
    {
      "name": "mrmarbles",
      "email": "bcarr14@gmail.com"
    }
  ],
  "directories": {},
  "_shasum": "67de39db9895251cc1e92ed32139316e75de1bee",
  "_resolved": "https://registry.npmjs.org/stringrouter/-/stringrouter-0.3.3.tgz"
}
